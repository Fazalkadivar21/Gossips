================================================
File: backend/auth.php
================================================
<?php
// Include database connection
include_once 'db_connection.php';

// Function to authenticate user
function authenticateUser($email, $password) {
    global $pdo; // Access the PDO connection variable

    // Validate input
    if (empty($email) || empty($password)) {
        return ["success" => false, "message" => "Email and password are required!"];
    }

    try {
        // Prepare SQL query to fetch user by email
        $query = "SELECT id, username, password_hash, is_online FROM users WHERE email = :email";
        $stmt = $pdo->prepare($query);
        $stmt->execute([':email' => $email]);

        // Check if user exists
        $user = $stmt->fetch(PDO::FETCH_ASSOC);
        if (!$user) {
            return ["success" => false, "message" => "Invalid email or password!"];
        }

        // Verify password
        if (!password_verify($password, $user['password_hash'])) {
            return ["success" => false, "message" => "Invalid email or password!"];
        }

        // Generate session token
        $token = bin2hex(random_bytes(32)); // Generate a 64-character token
        $userId = $user['id'];

        // Store session token in the database
        $tokenQuery = "INSERT INTO sessions (user_id, token, expires_at) VALUES (:user_id, :token, :expires_at)";
        $expiresAt = date('Y-m-d H:i:s', strtotime('+1 hour')); // Token expires in 1 hour
        $tokenStmt = $pdo->prepare($tokenQuery);
        $tokenStmt->execute([
            ':user_id' => $userId,
            ':token' => $token,
            ':expires_at' => $expiresAt
        ]);

        // Update user online status
        $updateStatusQuery = "UPDATE users SET is_online = TRUE, last_active = :last_active WHERE id = :id";
        $lastActive = date('Y-m-d H:i:s');
        $updateStmt = $pdo->prepare($updateStatusQuery);
        $updateStmt->execute([
            ':last_active' => $lastActive,
            ':id' => $userId
        ]);

        // Return success response with token
        return [
            "success" => true,
            "token" => $token,
            "username" => $user['username'],
            "user_id" => $userId
        ];
    } catch (PDOException $e) {
        return ["success" => false, "message" => "Error: " . $e->getMessage()];
    }
}

// Check if request is POST
if ($_SERVER['REQUEST_METHOD'] === 'POST') {
    // Get POST data
    $email = $_POST['email'];
    $password = $_POST['password'];

    // Call authenticateUser function
    $response = authenticateUser($email, $password);

    // Return response as JSON (for API use)
    header('Content-Type: application/json');
    echo json_encode($response);
}
?>



================================================
File: backend/createUser.php
================================================
<?php
// Include database connection
include_once 'db_connection.php';

// Function to handle user creation
function createUser($username, $email, $password, $profilePicture) {
    global $pdo; // Access the PDO connection variable

    // Validate input
    if (empty($username) || empty($email) || empty($password)) {
        return json_encode(["status" => "error", "message" => "All fields are required!"]);
    }

    if (!filter_var($email, FILTER_VALIDATE_EMAIL)) {
        return json_encode(["status" => "error", "message" => "Invalid email format!"]);
    }

    try {
        // Check if the username or email already exists
        $checkQuery = "SELECT * FROM users WHERE username = :username OR email = :email";
        $stmt = $pdo->prepare($checkQuery);
        $stmt->execute(['username' => $username, 'email' => $email]);
        $result = $stmt->fetchAll(PDO::FETCH_ASSOC);

        if (count($result) > 0) {
            return json_encode(["status" => "error", "message" => "Username or email already exists!"]);
        }

        // Hash the password
        $hashedPassword = password_hash($password, PASSWORD_BCRYPT);

        // Handle profile picture upload
        $filePath = null;
        if ($profilePicture['error'] === 0) {
            $allowedTypes = ['image/jpeg', 'image/png'];
            $maxSize = 5 * 1024 * 1024; // 5MB

            // Validate file type and size
            if (!in_array($profilePicture['type'], $allowedTypes)) {
                return json_encode(["status" => "error", "message" => "Invalid file type!"]);
            }
            if ($profilePicture['size'] > $maxSize) {
                return json_encode(["status" => "error", "message" => "File size exceeds 5MB!"]);
            }

            // Generate unique filename and save the file
            $fileName = uniqid() . '_' . basename($profilePicture['name']);
            $filePath = 'uploads/' . $fileName;

            if (!move_uploaded_file($profilePicture['tmp_name'], $filePath)) {
                return json_encode(["status" => "error", "message" => "Error uploading the profile picture."]);
            }
        }

        // Insert user into database
        $insertQuery = "INSERT INTO users (username, email, password_hash, profile_picture, is_online, last_active)
                        VALUES (:username, :email, :password, :profile_picture, :is_online, :last_active)";
        $stmt = $pdo->prepare($insertQuery);

        // Prepare parameters
        $params = [
            ':username' => $username,
            ':email' => $email,
            ':password' => $hashedPassword,
            ':profile_picture' => $filePath,
            ':is_online' => 0, // Default online status is false
            ':last_active' => date('Y-m-d H:i:s'), // Default last active timestamp
        ];

        if ($stmt->execute($params)) {
            return json_encode(["status" => "success", "message" => "User created successfully!"]);
        } else {
            return json_encode(["status" => "error", "message" => "Error inserting data into database."]);
        }
    } catch (PDOException $e) {
        // Handle PDO exceptions
        return json_encode(["status" => "error", "message" => "Error: " . $e->getMessage()]);
    }
}

// Check if request is POST
if ($_SERVER['REQUEST_METHOD'] === 'POST') {
    // Get POST data
    $username = $_POST['username'];
    $email = $_POST['email'];
    $password = $_POST['password'];
    $profilePicture = $_FILES['profile_picture'];

    // Call createUser function
    $response = createUser($username, $email, $password, $profilePicture);

    // Return JSON response
    header('Content-Type: application/json');
    echo $response;
}
?>



================================================
File: backend/db_connection.php
================================================
 <?php
// Allow from any origin (you can restrict this to specific origins)
header("Access-Control-Allow-Origin: *");

// Allow specific HTTP methods (you can customize these if needed)
header("Access-Control-Allow-Methods: GET, POST, PUT, DELETE, OPTIONS");

// Allow specific headers (you can add or modify headers here)
header("Access-Control-Allow-Headers: Content-Type, Authorization");

// Allow credentials (if you're sending cookies or credentials with requests)
// header("Access-Control-Allow-Credentials: true");

// Handle preflight requests (OPTIONS request)
if ($_SERVER['REQUEST_METHOD'] == 'OPTIONS') {
    exit;  // Preflight request, just exit without further processing
}


$dsn = 'mysql:host=localhost;dbname=justchat;charset=utf8mb4';
$username = 'root';
$password = 'h!arch21';

try {
    // Create a new PDO instance
    $pdo = new PDO($dsn, $username, $password);

    // Set error mode to exception for better debugging
    $pdo->setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION);

    /*echo "Connected successfully to the database using PDO!";*/
} catch (PDOException $e) {
    // Catch and display connection error
    echo "Connection failed: " . $e->getMessage();
}
?>



================================================
File: backend/deleteMessage.php
================================================
<?php
// Include database connection
include_once 'db_connection.php';

// Function to delete a message by its ID
function deleteMessage($messageId, $userId) {
    global $pdo; // Access the PDO connection variable

    try {
        // Check if the message exists and belongs to the user
        $query = "SELECT sender_id FROM messages WHERE id = :message_id";
        $stmt = $pdo->prepare($query);
        $stmt->execute([':message_id' => $messageId]);
        $message = $stmt->fetch(PDO::FETCH_ASSOC);

        if ($message) {
            if ($message['sender_id'] == $userId) {
                // Message belongs to the user, delete it
                $deleteQuery = "DELETE FROM messages WHERE id = :message_id";
                $deleteStmt = $pdo->prepare($deleteQuery);
                $deleteStmt->execute([':message_id' => $messageId]);

                if ($deleteStmt->rowCount() > 0) {
                    return "Message deleted successfully.";
                } else {
                    return "Failed to delete message.";
                }
            } else {
                return "You can only delete your own messages.";
            }
        } else {
            return "Message not found.";
        }
    } catch (PDOException $e) {
        return "Error: " . $e->getMessage();
    }
}

// Check if request is POST
if ($_SERVER['REQUEST_METHOD'] === 'POST') {
    // Get the messageId and userId from POST data
    $messageId = $_POST['message_id'];
    $userId = $_POST['user_id'];

    // Call deleteMessage function
    $response = deleteMessage($messageId, $userId);

    // Return response as JSON (for API use)
    header('Content-Type: application/json');
    echo json_encode(['message' => $response]);
}
?>



================================================
File: backend/loadChat.php
================================================
<?php
// Include database connection
include_once 'db_connection.php';

// Function to load messages between two users
function loadChat($userId, $otherUserId, $limit = 5000, $offset = 0) {
    global $pdo; // Access the PDO connection variable

    try {
        // Prepare SQL query to get messages between the two users
        $query = "
    SELECT 
        messages.id,
        messages.sender_id,
        messages.receiver_id,
        messages.message,
        messages.type,
        messages.file_id,
        messages.timestamp
    FROM messages
    WHERE (messages.sender_id = :userId AND messages.receiver_id = :otherUserId) 
        OR (messages.sender_id = :otherUserId AND messages.receiver_id = :userId)
    ORDER BY messages.timestamp ASC
    LIMIT :limit OFFSET :offset
";
        // Prepare the statement
        $stmt = $pdo->prepare($query);

        // Bind the parameters
        $stmt->bindParam(':userId', $userId, PDO::PARAM_INT);
        $stmt->bindParam(':otherUserId', $otherUserId, PDO::PARAM_INT);
        $stmt->bindParam(':limit', $limit, PDO::PARAM_INT);
        $stmt->bindParam(':offset', $offset, PDO::PARAM_INT);

        // Execute the query
        $stmt->execute();

        // Fetch messages
        $messages = $stmt->fetchAll(PDO::FETCH_ASSOC);

        // Check if there are any messages
        if ($messages) {
            return $messages;
        } else {
            return "No messages found.";
        }
    } catch (PDOException $e) {
        return "Error: " . $e->getMessage();
    }
}

// Check if request is POST
if ($_SERVER['REQUEST_METHOD'] === 'POST') {
    // Get the userId and otherUserId from POST data
    $userId = $_POST['user_id'];
    $otherUserId = $_POST['other_user_id'];
    $limit = isset($_POST['limit']) ? $_POST['limit'] : 5000; // Default limit
    $offset = isset($_POST['offset']) ? $_POST['offset'] : 0; // Default offset

    // Call loadChat function
    $response = loadChat($userId, $otherUserId, $limit, $offset);

    // Return response as JSON (for API use)
    header('Content-Type: application/json');
    echo json_encode($response);
}
?>



================================================
File: backend/loadChatList.php
================================================
<?php
// Include database connection
include_once 'db_connection.php';

// Function to load the chat list for a user
function loadChatList($userId) {
    global $pdo; // Access the PDO connection variable

    try {
        // Prepare SQL query to get distinct conversations for the user
        $query = "
            SELECT 
                IF(sender_id = :userId, receiver_id, sender_id) AS other_user_id,
                IF(sender_id = :userId, receiver_id, sender_id) AS other_user_username,
                messages.message,
                messages.timestamp,
                users.username AS other_user_username,
                users.profile_picture AS other_user_profile_picture
            FROM messages
            JOIN users ON users.id = IF(sender_id = :userId, receiver_id, sender_id)
            WHERE sender_id = :userId OR receiver_id = :userId
            ORDER BY messages.timestamp DESC
            LIMIT 50
        ";

        // Prepare the statement
        $stmt = $pdo->prepare($query);

        // Bind the userId parameter
        $stmt->bindParam(':userId', $userId, PDO::PARAM_INT);

        // Execute the query
        $stmt->execute();

        // Fetch chats
        $chats = $stmt->fetchAll(PDO::FETCH_ASSOC);

        // Check if there are any chats
        if ($chats) {
            return $chats;
        } else {
            return "No chats found.";
        }
    } catch (PDOException $e) {
        return "Error: " . $e->getMessage();
    }
}

// Check if request is POST
if ($_SERVER['REQUEST_METHOD'] === 'POST') {
    // Get the userId from POST data
    $userId = $_POST['user_id'];

    // Call loadChatList function
    $response = loadChatList($userId);

    // Return response as JSON (for API use)
    header('Content-Type: application/json');
    echo json_encode($response);
}
?>



================================================
File: backend/searchUser.php
================================================
<?php
// Include database connection
include_once 'db_connection.php';

// Function to search users
function searchUsers($query, $currentUserId) {
    global $pdo; // Use the PDO connection

    // Prepare SQL query to search users
    $searchQuery = "
        SELECT 
            id,
            username,
            profile_picture,
            is_online,
            last_active
        FROM users
        WHERE 
            id != :current_user_id AND
            username LIKE :search_term
        LIMIT 20
    ";

    // Add wildcard to search query
    $searchTerm = "%$query%";

    try {
        // Prepare the statement
        $stmt = $pdo->prepare($searchQuery);

        // Bind the parameters
        $stmt->bindParam(':current_user_id', $currentUserId, PDO::PARAM_INT);
        $stmt->bindParam(':search_term', $searchTerm, PDO::PARAM_STR);

        // Execute the query
        $stmt->execute();

        // Fetch results
        $users = $stmt->fetchAll(PDO::FETCH_ASSOC);

        // Return users if found, else return empty array
        return $users;

    } catch (PDOException $e) {
        // Handle exception (e.g., log it)
        return [];
    }
}

// Check if request is POST
if ($_SERVER['REQUEST_METHOD'] === 'POST') {
    $query = $_POST['query'];
    $currentUserId = $_POST['user_id'];

    // Call searchUsers function
    $response = searchUsers($query, $currentUserId);

    // Return response as JSON
    header('Content-Type: application/json');
    echo json_encode($response);
}
?>



================================================
File: backend/sendMessage.php
================================================
<?php
// Include database connection
include_once 'db_connection.php';

// Function to send a message
function sendMessage($senderId, $receiverId, $message, $type = 'text', $file = null) {
    global $pdo;

    try {
        $fileId = null;
        $filePath = null;

        // Handle file upload if present
        if ($file && $file['error'] === 0) {
            // Create uploads directory if it doesn't exist
            if (!file_exists('uploads')) {
                mkdir('uploads', 0777, true);
            }

            $fileName = uniqid() . '_' . basename($file['name']);
            $uploadPath = 'uploads/' . $fileName;

            if (move_uploaded_file($file['tmp_name'], $uploadPath)) {
                // Insert file record
                $fileQuery = "INSERT INTO files_shared (file_path, uploaded_by) VALUES (:filePath, :uploadedBy)";
                $fileStmt = $pdo->prepare($fileQuery);
                $fileStmt->execute([
                    ':filePath' => $uploadPath,
                    ':uploadedBy' => $senderId
                ]);
                $fileId = $pdo->lastInsertId();
                $filePath = $uploadPath;
            }
        }

        // Insert message
        $query = "INSERT INTO messages (sender_id, receiver_id, message, type, file_id, timestamp) 
                 VALUES (:senderId, :receiverId, :message, :type, :fileId, NOW())";

        $stmt = $pdo->prepare($query);
        $stmt->execute([
            ':senderId' => $senderId,
            ':receiverId' => $receiverId,
            ':message' => $message,
            ':type' => $type,
            ':fileId' => $fileId
        ]);

        $messageId = $pdo->lastInsertId();

        // Return success response with message details
        return [
            'success' => true,
            'message' => 'Message sent successfully',
            'data' => [
                'id' => $messageId,
                'sender_id' => $senderId,
                'receiver_id' => $receiverId,
                'message' => $message,
                'type' => $type,
                'file_path' => $filePath,
                'timestamp' => date('Y-m-d H:i:s')
            ]
        ];
    } catch (PDOException $e) {
        return [
            'success' => false,
            'message' => 'Error: ' . $e->getMessage()
        ];
    }
}

// Check if request is POST
if ($_SERVER['REQUEST_METHOD'] === 'POST') {
    $senderId = $_POST['sender_id'];
    $receiverId = $_POST['receiver_id'];
    $message = $_POST['message'];
    $type = $_POST['type'] ?? 'text';
    $file = isset($_FILES['file']) ? $_FILES['file'] : null;

    // Call sendMessage function
    $response = sendMessage($senderId, $receiverId, $message, $type, $file);

    // Return response as JSON
    header('Content-Type: application/json');
    echo json_encode($response);
}
?>

================================================
File: backend/test.php
================================================



================================================
File: frontend/eslint.config.js
================================================
import js from '@eslint/js';
import globals from 'globals';
import reactHooks from 'eslint-plugin-react-hooks';
import reactRefresh from 'eslint-plugin-react-refresh';
import tseslint from 'typescript-eslint';

export default tseslint.config(
  { ignores: ['dist'] },
  {
    extends: [js.configs.recommended, ...tseslint.configs.recommended],
    files: ['**/*.{ts,tsx}'],
    languageOptions: {
      ecmaVersion: 2020,
      globals: globals.browser,
    },
    plugins: {
      'react-hooks': reactHooks,
      'react-refresh': reactRefresh,
    },
    rules: {
      ...reactHooks.configs.recommended.rules,
      'react-refresh/only-export-components': [
        'warn',
        { allowConstantExport: true },
      ],
    },
  }
);


================================================
File: frontend/index.html
================================================
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="./chat.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Gossips</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.tsx"></script>
    
  </body>
</html>


================================================
File: frontend/package.json
================================================
{
  "name": "vite-react-typescript-starter",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "lint": "eslint .",
    "preview": "vite preview",
    "peer-server": "peerjs --port 9000 --key peerjs --path /",
    "server": "node server.js"
  },
  "dependencies": {
    "axios": "^1.6.7",
    "cors": "^2.8.5",
    "express": "^4.18.3",
    "framer-motion": "^11.0.8",
    "lucide-react": "^0.344.0",
    "peer": "^1.0.2",
    "peerjs": "^1.5.2",
    "react": "^18.3.1",
    "react-dom": "^18.3.1",
    "react-router-dom": "^6.22.3",
    "socket.io": "^4.7.4",
    "socket.io-client": "^4.7.4"
  },
  "devDependencies": {
    "@eslint/js": "^9.9.1",
    "@types/react": "^18.3.5",
    "@types/react-dom": "^18.3.0",
    "@vitejs/plugin-react": "^4.3.1",
    "autoprefixer": "^10.4.18",
    "eslint": "^9.9.1",
    "eslint-plugin-react-hooks": "^5.1.0-rc.0",
    "eslint-plugin-react-refresh": "^0.4.11",
    "globals": "^15.9.0",
    "postcss": "^8.4.35",
    "tailwindcss": "^3.4.1",
    "typescript": "^5.5.3",
    "typescript-eslint": "^8.3.0",
    "vite": "^5.4.2"
  }
}

================================================
File: frontend/postcss.config.js
================================================
export default {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
};


================================================
File: frontend/server.js
================================================
import express from 'express';
import { createServer } from 'http';
import { Server } from 'socket.io';
import cors from 'cors';
import { fileURLToPath } from 'url';
import { dirname } from 'path';
import { PeerServer } from 'peer';

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

const app = express();
const httpServer = createServer(app);

// Enable CORS
app.use(cors());

// Create Socket.IO server
const io = new Server(httpServer, {
  cors: {
    origin: "http://localhost:5173",
    methods: ["GET", "POST"]
  }
});

// Create PeerJS server
const peerServer = PeerServer({
  port: 9000,
  path: '/',
  proxied: true
});

// Store connected users
const connectedUsers = new Map();

// Socket.IO connection handling
io.on('connection', (socket) => {
  console.log('User connected:', socket.id);

  // Handle user registration
  socket.on('register-user', (userData) => {
    console.log('User registered:', userData);
    connectedUsers.set(userData.id, {
      socket: socket.id,
      ...userData
    });
    
    // Broadcast updated user list
    io.emit('users-updated', Array.from(connectedUsers.values()).map(user => ({
      id: user.id,
      username: user.username,
      isOnline: true
    })));
  });

  // Handle call initiation
  socket.on('call-user', ({ targetUserId, callerId, callerName, isVideo }) => {
    const targetUser = connectedUsers.get(targetUserId);
    if (targetUser) {
      io.to(targetUser.socket).emit('incoming-call', {
        callerId,
        callerName,
        isVideo
      });
    }
  });

  // Handle call acceptance
  socket.on('call-accepted', ({ targetUserId, accepterId }) => {
    const targetUser = connectedUsers.get(targetUserId);
    if (targetUser) {
      io.to(targetUser.socket).emit('call-accepted', { accepterId });
    }
  });

  // Handle call rejection
  socket.on('call-rejected', ({ targetUserId, rejecterId }) => {
    const targetUser = connectedUsers.get(targetUserId);
    if (targetUser) {
      io.to(targetUser.socket).emit('call-rejected', { rejecterId });
    }
  });

  // Handle call ended
  socket.on('call-ended', ({ targetUserId, enderId }) => {
    const targetUser = connectedUsers.get(targetUserId);
    if (targetUser) {
      io.to(targetUser.socket).emit('call-ended', { enderId });
    }
  });

  // Handle disconnection
  socket.on('disconnect', () => {
    console.log('User disconnected:', socket.id);
    
    // Find and remove disconnected user
    for (const [userId, user] of connectedUsers.entries()) {
      if (user.socket === socket.id) {
        connectedUsers.delete(userId);
        // Broadcast updated user list
        io.emit('users-updated', Array.from(connectedUsers.values()).map(user => ({
          id: user.id,
          username: user.username,
          isOnline: true
        })));
        break;
      }
    }
  });
});

// Start the server
const PORT = process.env.PORT || 3001;
httpServer.listen(PORT, () => {
  console.log(`Server running on port ${PORT}`);
  console.log(`PeerJS server running on port 9000`);
});

================================================
File: frontend/tailwind.config.js
================================================
/** @type {import('tailwindcss').Config} */
export default {
  content: ['./index.html', './src/**/*.{js,ts,jsx,tsx}'],
  darkMode: 'class',
  theme: {
    extend: {
      colors: {
        discord: {
          primary: '#5865F2',
          dark: {
            900: '#202225', // Sidebar
            800: '#2f3136', // Channel list
            700: '#36393f', // Main chat
            600: '#4f545c', // Input background
            500: '#b9bbbe', // Text muted
          },
        },
      },
    },
  },
  plugins: [],
};

================================================
File: frontend/tsconfig.app.json
================================================
{
  "compilerOptions": {
    "target": "ES2020",
    "useDefineForClassFields": true,
    "lib": ["ES2020", "DOM", "DOM.Iterable"],
    "module": "ESNext",
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "isolatedModules": true,
    "moduleDetection": "force",
    "noEmit": true,
    "jsx": "react-jsx",

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true
  },
  "include": ["src"]
}


================================================
File: frontend/tsconfig.json
================================================
{
  "files": [],
  "references": [
    { "path": "./tsconfig.app.json" },
    { "path": "./tsconfig.node.json" }
  ]
}


================================================
File: frontend/tsconfig.node.json
================================================
{
  "compilerOptions": {
    "target": "ES2022",
    "lib": ["ES2023"],
    "module": "ESNext",
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "isolatedModules": true,
    "moduleDetection": "force",
    "noEmit": true,

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true
  },
  "include": ["vite.config.ts"]
}


================================================
File: frontend/vite.config.ts
================================================
import { defineConfig } from 'vite';
import react from '@vitejs/plugin-react';

// https://vitejs.dev/config/
export default defineConfig({
  plugins: [react()],
  optimizeDeps: {
    include: ['lucide-react'],
  },
  server: {
    proxy: {
      '/backend': {
        target: 'http://localhost:5000/',
      },
    },
  },
});


================================================
File: frontend/.gitignore
================================================
# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
pnpm-debug.log*
lerna-debug.log*

node_modules
dist
dist-ssr
*.local

# Editor directories and files
.vscode/*
!.vscode/extensions.json
.idea
.DS_Store
*.suo
*.ntvs*
*.njsproj
*.sln
*.sw?


================================================
File: frontend/src/App.tsx
================================================
import { BrowserRouter as Router, Routes, Route, Navigate } from 'react-router-dom';
import { ThemeProvider } from './contexts/ThemeContext';
import { AuthProvider } from './contexts/AuthContext';
import { AuthGuard } from './components/AuthGuard';
import { Login } from './pages/Login';
import { Signup } from './pages/Signup';
import { Chat } from './pages/Chat';
import { CallProvider } from './contexts/CallContext';
import { CallView } from './components/CallView';
import { CallNotification } from './components/CallNotification';
import { useAuth } from './contexts/AuthContext';

const AppContent = () => {
  const { user } = useAuth();
  
  return (
    <CallProvider currentUser={user}>
      <Routes>
        <Route path="/login" element={<Login />} />
        <Route path="/signup" element={<Signup />} />
        <Route
          path="/"
          element={
            <AuthGuard>
              <>
                <Chat />
                <CallView />
                <CallNotification />
              </>
            </AuthGuard>
          }
        />
        <Route path="*" element={<Navigate to="/" replace />} />
      </Routes>
    </CallProvider>
  );
};

function App() {
  return (
    <Router>
      <ThemeProvider>
        <AuthProvider>
          <AppContent />
        </AuthProvider>
      </ThemeProvider>
    </Router>
  );
}

export default App;

================================================
File: frontend/src/index.css
================================================
@tailwind base;
@tailwind components;
@tailwind utilities;

@layer base {
  body {
    @apply bg-gray-50 dark:bg-discord-dark-700 text-gray-900 dark:text-gray-100;
  }
}

.message-bubble {
  @apply relative px-3 py-2 max-w-[70%] rounded-lg;
}

.message-bubble::before {
  content: '';
  @apply absolute top-0 w-0 h-0 border-8 border-transparent;
}

.message-bubble.sent {
  @apply bg-discord-primary/10 dark:bg-discord-primary/20 ml-auto;
}

.message-bubble.sent::before {
  @apply -right-2 border-l-discord-primary/10 dark:border-l-discord-primary/20;
}

.message-bubble.received {
  @apply bg-white dark:bg-discord-dark-800;
}

.message-bubble.received::before {
  @apply -left-2 border-r-white dark:border-r-discord-dark-800;
}

================================================
File: frontend/src/main.tsx
================================================
import { StrictMode } from 'react';
import { createRoot } from 'react-dom/client';
import { ThemeProvider } from './contexts/ThemeContext';
import App from './App.tsx';
import './index.css';

createRoot(document.getElementById('root')!).render(
  <StrictMode>
    <ThemeProvider>
      <App />
    </ThemeProvider>
  </StrictMode>
);

================================================
File: frontend/src/vite-env.d.ts
================================================
/// <reference types="vite/client" />


================================================
File: frontend/src/components/AuthGuard.tsx
================================================
import React from 'react';
import { Navigate } from 'react-router-dom';
import { useAuth } from '../contexts/AuthContext';

interface AuthGuardProps {
  children: React.ReactNode;
}

export const AuthGuard: React.FC<AuthGuardProps> = ({ children }) => {
  const { user, isLoading } = useAuth();

  if (isLoading) {
    return (
      <div className="h-screen flex items-center justify-center bg-gray-50 dark:bg-discord-dark-900">
        <div className="animate-spin rounded-full h-8 w-8 border-t-2 border-b-2 border-discord-primary"></div>
      </div>
    );
  }

  if (!user) {
    return <Navigate to="/login" replace />;
  }

  return <>{children}</>;
};

================================================
File: frontend/src/components/CallControls.tsx
================================================
import React from 'react';
import { Video, VideoOff, Mic, MicOff, PhoneOff } from 'lucide-react';
import { useCall } from '../contexts/CallContext';
import { motion } from 'framer-motion';

export const CallControls: React.FC = () => {
  const { toggleVideo, toggleAudio, endCall, isVideo, isMuted } = useCall();

  return (
    <motion.div
      initial={{ y: 20, opacity: 0 }}
      animate={{ y: 0, opacity: 1 }}
      className="absolute bottom-6 left-1/2 transform -translate-x-1/2 flex items-center space-x-4 bg-gray-900/80 p-4 rounded-full backdrop-blur-sm"
    >
      <motion.button
        whileHover={{ scale: 1.1 }}
        whileTap={{ scale: 0.9 }}
        onClick={toggleVideo}
        className="p-4 rounded-full hover:bg-gray-700 transition-colors"
      >
        {isVideo ? (
          <Video className="w-6 h-6 text-white" />
        ) : (
          <VideoOff className="w-6 h-6 text-white" />
        )}
      </motion.button>
      <motion.button
        whileHover={{ scale: 1.1 }}
        whileTap={{ scale: 0.9 }}
        onClick={toggleAudio}
        className="p-4 rounded-full hover:bg-gray-700 transition-colors"
      >
        {isMuted ? (
          <MicOff className="w-6 h-6 text-white" />
        ) : (
          <Mic className="w-6 h-6 text-white" />
        )}
      </motion.button>
      <motion.button
        whileHover={{ scale: 1.1 }}
        whileTap={{ scale: 0.9 }}
        onClick={endCall}
        className="p-4 rounded-full bg-red-500 hover:bg-red-600 transition-colors"
      >
        <PhoneOff className="w-6 h-6 text-white" />
      </motion.button>
    </motion.div>
  );
};

================================================
File: frontend/src/components/CallNotification.tsx
================================================
import React from 'react';
import { Phone, Video } from 'lucide-react';
import { motion } from 'framer-motion';
import { useCall } from '../contexts/CallContext';

export const CallNotification: React.FC = () => {
  const { incomingCall, answerCall } = useCall();

  if (!incomingCall) return null;

  const isVideoCall = incomingCall.metadata?.isVideo;
  const callerName = incomingCall.metadata?.callerName || 'Unknown';

  return (
    <motion.div
      initial={{ opacity: 0, y: -50 }}
      animate={{ opacity: 1, y: 0 }}
      exit={{ opacity: 0, y: -50 }}
      className="fixed top-4 right-4 bg-white dark:bg-discord-dark-800 p-4 rounded-lg shadow-lg z-50"
    >
      <div className="flex items-center space-x-4">
        <div className="bg-discord-primary rounded-full p-3">
          {isVideoCall ? (
            <Video className="w-6 h-6 text-white" />
          ) : (
            <Phone className="w-6 h-6 text-white" />
          )}
        </div>
        <div>
          <h3 className="font-semibold dark:text-white">Incoming {isVideoCall ? 'Video' : 'Audio'} Call</h3>
          <p className="text-sm text-gray-500 dark:text-gray-400">from {callerName}</p>
        </div>
      </div>
      <div className="mt-4 flex justify-end space-x-2">
        <button
          onClick={() => answerCall(incomingCall)}
          className="px-4 py-2 bg-green-500 text-white rounded-lg hover:bg-green-600 transition-colors"
        >
          Answer
        </button>
      </div>
    </motion.div>
  );
};

================================================
File: frontend/src/components/CallView.tsx
================================================
import React, { useEffect, useRef } from 'react';
import { useCall } from '../contexts/CallContext';
import { CallControls } from './CallControls';
import { motion, AnimatePresence } from 'framer-motion';

export const CallView: React.FC = () => {
  const { localStream, remoteStream, isInCall, isVideo, caller } = useCall();
  const localVideoRef = useRef<HTMLVideoElement>(null);
  const remoteVideoRef = useRef<HTMLVideoElement>(null);

  useEffect(() => {
    if (localVideoRef.current && localStream) {
      localVideoRef.current.srcObject = localStream;
    }
  }, [localStream]);

  useEffect(() => {
    if (remoteVideoRef.current && remoteStream) {
      remoteVideoRef.current.srcObject = remoteStream;
    }
  }, [remoteStream]);

  if (!isInCall) return null;

  return (
    <AnimatePresence>
      <motion.div
        initial={{ opacity: 0 }}
        animate={{ opacity: 1 }}
        exit={{ opacity: 0 }}
        className="fixed inset-0 bg-black/90 z-50 flex items-center justify-center"
      >
        <div className="relative w-full h-full">
          {/* Remote Video/Audio Stream */}
          {isVideo ? (
            <video
              ref={remoteVideoRef}
              autoPlay
              playsInline
              className="w-full h-full object-cover"
            />
          ) : (
            <div className="w-full h-full flex items-center justify-center">
              <div className="text-center">
                <div className="w-32 h-32 bg-discord-primary rounded-full flex items-center justify-center mb-4">
                  <span className="text-4xl text-white">
                    {caller?.username?.[0]?.toUpperCase()}
                  </span>
                </div>
                <h2 className="text-2xl text-white font-semibold">
                  {caller?.username}
                </h2>
                <p className="text-gray-400">Audio Call</p>
              </div>
            </div>
          )}

          {/* Local Video Stream (if video is enabled) */}
          {localStream && isVideo && (
            <motion.div
              initial={{ scale: 0, opacity: 0 }}
              animate={{ scale: 1, opacity: 1 }}
              transition={{ type: "spring", stiffness: 260, damping: 20 }}
              className="absolute bottom-24 right-4 w-48 h-36 bg-black rounded-lg overflow-hidden shadow-lg border-2 border-white/20"
              drag
              dragConstraints={{
                top: 0,
                left: 0,
                right: window.innerWidth - 192, // 48rem = 192px
                bottom: window.innerHeight - 144, // 36rem = 144px
              }}
            >
              <video
                ref={localVideoRef}
                autoPlay
                playsInline
                muted
                className="w-full h-full object-cover"
              />
            </motion.div>
          )}

          {/* Call Controls */}
          <CallControls />
        </div>
      </motion.div>
    </AnimatePresence>
  );
};

================================================
File: frontend/src/components/ChatHeader.tsx
================================================
import React from 'react';
import { User } from '../types';
import { Phone, Video, MoreVertical } from 'lucide-react';
import { useCall } from '../contexts/CallContext';
import { motion } from 'framer-motion';

interface ChatHeaderProps {
  user: User;
}

export const ChatHeader: React.FC<ChatHeaderProps> = ({ user }) => {
  const { makeCall, isInCall } = useCall();

  return (
    <div className="bg-white dark:bg-discord-dark-800 p-4 border-b border-gray-200 dark:border-discord-dark-900 flex items-center justify-between">
      <div className="flex items-center space-x-3">
        <motion.img
          initial={{ scale: 0.8 }}
          animate={{ scale: 1 }}
          src={user.avatar || `https://ui-avatars.com/api/?name=${user.username}&background=random`}
          alt={user.username}
          className="w-10 h-10 rounded-full"
        />
        <div>
          <h3 className="font-semibold text-gray-900 dark:text-gray-100">{user.username}</h3>
          <p className="text-sm text-gray-500 dark:text-gray-400">
            {user.isOnline ? 'online' : 'last seen recently'}
          </p>
        </div>
      </div>
      <div className="flex items-center space-x-2">
        <motion.button
          whileHover={{ scale: 1.05 }}
          whileTap={{ scale: 0.95 }}
          onClick={() => makeCall(user, false)}
          disabled={isInCall}
          className={`p-3 rounded-full transition-colors ${
            isInCall
              ? 'bg-red-500 text-white'
              : 'hover:bg-gray-100 dark:hover:bg-discord-dark-700 text-gray-600 dark:text-gray-400'
          }`}
        >
          <Phone className="w-5 h-5" />
        </motion.button>
        <motion.button
          whileHover={{ scale: 1.05 }}
          whileTap={{ scale: 0.95 }}
          onClick={() => makeCall(user, true)}
          disabled={isInCall}
          className={`p-3 rounded-full transition-colors ${
            isInCall
              ? 'bg-red-500 text-white'
              : 'hover:bg-gray-100 dark:hover:bg-discord-dark-700 text-gray-600 dark:text-gray-400'
          }`}
        >
          <Video className="w-5 h-5" />
        </motion.button>
        <motion.button
          whileHover={{ scale: 1.05 }}
          whileTap={{ scale: 0.95 }}
          className="p-3 rounded-full hover:bg-gray-100 dark:hover:bg-discord-dark-700 text-gray-600 dark:text-gray-400"
        >
          <MoreVertical className="w-5 h-5" />
        </motion.button>
      </div>
    </div>
  );
};

================================================
File: frontend/src/components/ChatWindow.tsx
================================================
import React, { useEffect, useRef, useState } from 'react';
import { Message, User } from '../types';
import { MessageBubble } from './MessageBubble';
import { MessageInput } from './MessageInput';
import { ChatHeader } from './ChatHeader';

interface ChatWindowProps {
  currentUser: User;
  selectedUser: User | null;
  messages: Message[];
  onSendMessage: (content: string, type: 'text' | 'image' | 'file', file?: File) => void;
  loading: boolean;
}

export const ChatWindow: React.FC<ChatWindowProps> = ({
  currentUser,
  selectedUser,
  messages,
  onSendMessage,
  loading,
}) => {
  const messagesEndRef = useRef<HTMLDivElement>(null);
  const chatContainerRef = useRef<HTMLDivElement>(null);
  const [shouldAutoScroll, setShouldAutoScroll] = useState(true);

  // Handle scroll events to determine if we should auto-scroll
  const handleScroll = () => {
    if (!chatContainerRef.current) return;
    
    const { scrollTop, scrollHeight, clientHeight } = chatContainerRef.current;
    const isNearBottom = scrollHeight - (scrollTop + clientHeight) < 100;
    setShouldAutoScroll(isNearBottom);
  };

  // Auto-scroll to bottom when new messages arrive (if shouldAutoScroll is true)
  useEffect(() => {
    if (shouldAutoScroll && messagesEndRef.current) {
      messagesEndRef.current.scrollIntoView({ behavior: 'smooth' });
    }
  }, [messages, shouldAutoScroll]);

  if (!selectedUser) {
    return (
      <div className="flex-1 flex items-center justify-center bg-gray-50 dark:bg-discord-dark-700">
        <div className="text-center text-gray-500 dark:text-gray-400">
          <p className="text-lg">Select a chat to start messaging</p>
        </div>
      </div>
    );
  }

  return (
    <div className="flex-1 flex flex-col h-full">
      <ChatHeader user={selectedUser} />
      <div 
        ref={chatContainerRef}
        onScroll={handleScroll}
        className="flex-1 overflow-y-auto p-4 space-y-2 bg-gray-50 dark:bg-discord-dark-700"
      >
        {loading ? (
          <div className="flex items-center justify-center h-full">
            <div className="animate-spin rounded-full h-8 w-8 border-t-2 border-b-2 border-discord-primary"></div>
          </div>
        ) : messages.length === 0 ? (
          <div className="flex items-center justify-center h-full">
            <p className="text-gray-500 dark:text-gray-400">
              No messages yet. Start the conversation!
            </p>
          </div>
        ) : (
          <>
            {messages.map((message) => (
              <MessageBubble
                key={message.id}
                message={message}
                isOwn={message.senderId === currentUser.id}
              />
            ))}
            <div ref={messagesEndRef} />
          </>
        )}
      </div>
      <MessageInput onSendMessage={onSendMessage} />
    </div>
  );
};

================================================
File: frontend/src/components/Header.tsx
================================================
import React, { useState } from 'react';
import { Menu, Search, LogOut } from 'lucide-react';
import { ThemeToggle } from './ThemeToggle';
import { useAuth } from '../contexts/AuthContext';
import { useNavigate } from 'react-router-dom';

export const Header: React.FC = () => {
  const [showMenu, setShowMenu] = useState(false);
  const { logout } = useAuth();
  const navigate = useNavigate();

  const handleLogout = () => {
    logout();
    navigate('/login');
  };

  return (
    <div className="bg-[#5865F2] dark:bg-[#36393f] text-white p-4 flex items-center justify-between relative">
      <h1 className="text-xl font-semibold">Gossips</h1>
      <div className="flex items-center space-x-4">
        <Search className="w-5 h-5 cursor-pointer" />
        <ThemeToggle />
        <button
          onClick={() => setShowMenu(!showMenu)}
          className="focus:outline-none"
        >
          <Menu className="w-5 h-5 cursor-pointer" />
        </button>

        {/* Dropdown Menu */}
        {showMenu && (
          <div className="absolute top-full right-2 mt-1 bg-white dark:bg-discord-dark-800 rounded-lg shadow-lg py-2 min-w-[160px] z-50">
            <button
              onClick={handleLogout}
              className="w-full px-4 py-2 text-left text-gray-700 dark:text-gray-200 hover:bg-gray-100 dark:hover:bg-discord-dark-700 flex items-center space-x-2"
            >
              <LogOut className="w-4 h-4" />
              <span>Logout</span>
            </button>
          </div>
        )}
      </div>
    </div>
  );
};


================================================
File: frontend/src/components/MessageBubble.tsx
================================================
import React from 'react';
import { Message } from '../types';
import { Check, FileText, Download } from 'lucide-react';
import { formatMessageTime } from '../utils/dateUtils';
import { motion } from 'framer-motion';

interface MessageBubbleProps {
  message: Message;
  isOwn: boolean;
}

export const MessageBubble: React.FC<MessageBubbleProps> = ({ message, isOwn }) => {
  const renderContent = () => {
    switch (message.type) {
      case 'image':
        return (
          <div className="relative group">
            <img 
              src={message.fileUrl ? `http://localhost:5000/${message.fileUrl}` : ''}
              alt="Shared"
              className="max-w-[300px] max-h-[300px] rounded-lg object-cover cursor-pointer"
              onClick={() => window.open(`http://localhost:5000/${message.fileUrl}`, '_blank')}
              onError={(e) => {
                const target = e.target as HTMLImageElement;
                target.src = 'https://via.placeholder.com/300x200?text=Image+Not+Found';
              }}
            />
            <div className="absolute inset-0 bg-black bg-opacity-0 group-hover:bg-opacity-10 transition-all duration-200 rounded-lg flex items-center justify-center">
              <Download className="w-6 h-6 text-white opacity-0 group-hover:opacity-100 transition-opacity duration-200" />
            </div>
          </div>
        );
      case 'file':
        return (
          <div className="flex items-center space-x-2 bg-gray-100 dark:bg-discord-dark-600 p-3 rounded-lg">
            <FileText className="w-8 h-8 text-discord-primary" />
            <div className="flex-1 min-w-0">
              <p className="text-sm font-medium truncate">{message.content}</p>
              <a
                href={`http://localhost:5000/${message.fileUrl}`}
                className="text-xs text-discord-primary hover:underline"
                target="_blank"
                rel="noopener noreferrer"
              >
                Download
              </a>
            </div>
          </div>
        );
      default:
        return <p>{message.content}</p>;
    }
  };

  return (
    <motion.div 
      className={`flex ${isOwn ? 'justify-end' : 'justify-start'} mb-4`}
      initial={{ 
        opacity: 0, 
        x: isOwn ? 20 : -20,
        scale: 0.95
      }}
      animate={{ 
        opacity: 1, 
        x: 0,
        scale: 1
      }}
      transition={{
        type: "spring",
        stiffness: 500,
        damping: 40
      }}
    >
      <div className={`message-bubble ${isOwn ? 'sent' : 'received'}`}>
        {renderContent()}
        <div className="flex items-center justify-end space-x-1 mt-1">
          <span className="text-xs text-gray-500">
            {formatMessageTime(message.timestamp)}
          </span>
          {isOwn && (
            <Check className="w-4 h-4 text-emerald-500" />
          )}
        </div>
      </div>
    </motion.div>
  );
};

================================================
File: frontend/src/components/MessageInput.tsx
================================================
import React, { useState } from 'react';
import { Paperclip, Send, Smile } from 'lucide-react';

interface MessageInputProps {
  onSendMessage: (content: string, type: 'text' | 'image' | 'file', file?: File) => void;
}

export const MessageInput: React.FC<MessageInputProps> = ({ onSendMessage }) => {
  const [message, setMessage] = useState('');

  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    if (message.trim()) {
      onSendMessage(message, 'text');
      setMessage('');
    }
  };

  const handleFileUpload = (e: React.ChangeEvent<HTMLInputElement>) => {
    const file = e.target.files?.[0];
    if (file) {
      const isImage = file.type.startsWith('image/');
      onSendMessage(file.name, isImage ? 'image' : 'file', file);
    }
  };

  return (
    <div className="bg-gray-100 dark:bg-discord-dark-800 p-3">
      <form onSubmit={handleSubmit} className="flex items-center space-x-2">
        <div className="flex items-center space-x-2">
          <Smile className="w-6 h-6 text-gray-500 dark:text-gray-400 cursor-pointer" />
          <label className="cursor-pointer">
            <input
              type="file"
              className="hidden"
              onChange={handleFileUpload}
              accept="image/*,.pdf,.doc,.docx"
            />
            <Paperclip className="w-6 h-6 text-gray-500 dark:text-gray-400" />
          </label>
        </div>
        <input
          type="text"
          value={message}
          onChange={(e) => setMessage(e.target.value)}
          placeholder="Type a message"
          className="flex-1 p-2 rounded-lg bg-white dark:bg-discord-dark-600 text-gray-900 dark:text-gray-100 focus:outline-none focus:ring-2 focus:ring-discord-primary"
        />
        <button
          type="submit"
          className="p-2 rounded-full bg-discord-primary text-white hover:bg-discord-primary/90"
        >
          <Send className="w-5 h-5" />
        </button>
      </form>
    </div>
  );
}

================================================
File: frontend/src/components/ThemeToggle.tsx
================================================
import React from 'react';
import { Moon, Sun } from 'lucide-react';
import { useTheme } from '../contexts/ThemeContext';

export const ThemeToggle: React.FC = () => {
  const { theme, toggleTheme } = useTheme();

  return (
    <button
      onClick={toggleTheme}
      className="p-2 rounded-full hover:bg-gray-200 dark:hover:bg-gray-700"
    >
      {theme === 'light' ? (
        <Moon className="w-5 h-5" />
      ) : (
        <Sun className="w-5 h-5" />
      )}
    </button>
  );
};

================================================
File: frontend/src/components/UserList.tsx
================================================
import React, { useState, useEffect } from 'react';
import { User } from '../types';
import { formatLastSeen } from '../utils/dateUtils';
import { Search } from 'lucide-react';
import api from '../lib/axios';
import { useAuth } from '../contexts/AuthContext';
import { motion, AnimatePresence } from 'framer-motion';

interface UserListProps {
  selectedUser: User | null;
  onSelectUser: (user: User) => void;
}

export const UserList: React.FC<UserListProps> = ({ selectedUser, onSelectUser }) => {
  const [users, setUsers] = useState<User[]>([]);
  const [searchQuery, setSearchQuery] = useState('');
  const [isSearching, setIsSearching] = useState(false);
  const { user: currentUser } = useAuth();

  // Fetch chat list (recent conversations)
  useEffect(() => {
    const fetchChatList = async () => {
      if (!currentUser) return;
      
      try {
        const formData = new FormData();
        formData.append('user_id', currentUser.id);

        const { data } = await api.post('/backend/loadChatList.php', formData);
        
        if (Array.isArray(data)) {
          // Create a Map to store unique users by ID
          const uniqueUsers = new Map();
          
          data.forEach((chat: any) => {
            if (!uniqueUsers.has(chat.other_user_id)) {
              uniqueUsers.set(chat.other_user_id, {
                id: chat.other_user_id,
                username: chat.other_user_username,
                email: '',
                isOnline: chat.is_online,
                avatar: chat.profile_picture ? `http://localhost:5000/${chat.profile_picture}` : null,
                lastSeen: new Date(chat.last_active || chat.last_message_time)
              });
            }
          });
          
          setUsers(Array.from(uniqueUsers.values()));
        }
      } catch (error) {
        console.error('Failed to load chat list:', error);
      }
    };

    fetchChatList();
    
    // Poll for updates every 30 seconds
    const interval = setInterval(fetchChatList, 30000);
    return () => clearInterval(interval);
  }, [currentUser]);

  // Search users
  const searchUsers = async (query: string) => {
    if (!query.trim() || !currentUser) return;
    
    setIsSearching(true);
    try {
      const formData = new FormData();
      formData.append('query', query);
      formData.append('user_id', currentUser.id);

      const { data } = await api.post('/search_users.php', formData);
      
      if (Array.isArray(data)) {
        // Create a Map to store unique users by ID
        const uniqueUsers = new Map();
        
        data.forEach((user: any) => {
          if (!uniqueUsers.has(user.id)) {
            uniqueUsers.set(user.id, {
              id: user.id,
              username: user.username,
              email: '',
              isOnline: user.is_online,
              avatar: user.profile_picture ? `http://localhost:5000/${user.profile_picture}` : null,
              lastSeen: new Date(user.last_active)
            });
          }
        });
        
        setUsers(Array.from(uniqueUsers.values()));
      }
    } catch (error) {
      console.error('Failed to search users:', error);
    } finally {
      setIsSearching(false);
    }
  };

  // Debounce search
  useEffect(() => {
    const timer = setTimeout(() => {
      if (searchQuery) {
        searchUsers(searchQuery);
      }
    }, 300);

    return () => clearTimeout(timer);
  }, [searchQuery]);

  return (
    <div className="flex flex-col h-full bg-white dark:bg-discord-dark-800">
      <div className="p-3 bg-gray-100 dark:bg-discord-dark-800 border-b border-gray-200 dark:border-discord-dark-900">
        <div className="relative">
          <input
            type="text"
            placeholder="Search users..."
            value={searchQuery}
            onChange={(e) => setSearchQuery(e.target.value)}
            className="w-full p-2 pl-9 bg-white dark:bg-discord-dark-600 text-gray-900 dark:text-gray-100 rounded-lg focus:outline-none focus:ring-2 focus:ring-discord-primary dark:focus:ring-discord-primary placeholder-gray-500 dark:placeholder-gray-400"
          />
          <Search className="w-5 h-5 absolute left-2 top-2.5 text-gray-400" />
          {isSearching && (
            <div className="absolute right-2 top-2">
              <div className="animate-spin rounded-full h-5 w-5 border-b-2 border-discord-primary"></div>
            </div>
          )}
        </div>
      </div>
      
      <div className="flex-1 overflow-y-auto">
        <AnimatePresence>
          {users.length === 0 ? (
            <motion.div
              initial={{ opacity: 0 }}
              animate={{ opacity: 1 }}
              exit={{ opacity: 0 }}
              className="p-4 text-center text-gray-500 dark:text-gray-400"
            >
              {searchQuery ? 'No users found' : 'No recent chats'}
            </motion.div>
          ) : (
            users.map((user) => (
              <motion.div
                key={user.id}
                initial={{ opacity: 0, y: 20 }}
                animate={{ opacity: 1, y: 0 }}
                exit={{ opacity: 0, y: -20 }}
                whileHover={{ scale: 1.02 }}
                whileTap={{ scale: 0.98 }}
                transition={{
                  type: "spring",
                  stiffness: 500,
                  damping: 30
                }}
                onClick={() => onSelectUser(user)}
                className={`p-3 cursor-pointer hover:bg-gray-50 dark:hover:bg-discord-dark-700 border-b dark:border-discord-dark-900 ${
                  selectedUser?.id === user.id ? 'bg-gray-50 dark:bg-discord-dark-700' : ''
                }`}
              >
                <div className="flex items-center space-x-3">
                  <div className="relative">
                    <motion.img
                      initial={{ scale: 0.8 }}
                      animate={{ scale: 1 }}
                      src={user.avatar || `https://ui-avatars.com/api/?name=${user.username}&background=random`}
                      alt={user.username}
                      className="w-12 h-12 rounded-full object-cover"
                    />
                    {user.isOnline && (
                      <motion.span
                        initial={{ scale: 0 }}
                        animate={{ scale: 1 }}
                        className="absolute bottom-0 right-0 w-3 h-3 bg-green-500 rounded-full border-2 border-white dark:border-discord-dark-800"
                      />
                    )}
                  </div>
                  <div className="flex-1">
                    <div className="flex justify-between items-start">
                      <h3 className="font-semibold dark:text-gray-100">{user.username}</h3>
                      <span className="text-xs text-gray-500 dark:text-gray-400">
                        {formatLastSeen(user.lastSeen)}
                      </span>
                    </div>
                    <p className="text-sm text-gray-500 dark:text-gray-400 truncate">
                      {user.isOnline ? 'online' : 'last seen recently'}
                    </p>``
                  </div>
                </div>
              </motion.div>
            ))
          )}
        </AnimatePresence>
      </div>
    </div>
  );
};

================================================
File: frontend/src/contexts/AuthContext.tsx
================================================
import React, { createContext, useContext, useState, useEffect } from 'react';
import { User } from '../types';
import api from '../lib/axios';

interface AuthContextType {
  user: User | null;
  login: (email: string, password: string) => Promise<void>;
  signup: (username: string, email: string, password: string, profilePicture?: File) => Promise<void>;
  logout: () => void;
  isLoading: boolean;
}

const AuthContext = createContext<AuthContextType | undefined>(undefined);

export const AuthProvider: React.FC<{ children: React.ReactNode }> = ({ children }) => {
  const [user, setUser] = useState<User | null>(null);
  const [isLoading, setIsLoading] = useState(true);

  useEffect(() => {
    const token = localStorage.getItem('authToken');
    const storedUser = localStorage.getItem('user');
    
    if (token && storedUser) {
      const userData = JSON.parse(storedUser);
      setUser(userData);
    }
    setIsLoading(false);
  }, []);

  const login = async (email: string, password: string) => {
    try {
      const formData = new FormData();
      formData.append('email', email);
      formData.append('password', password);

      const { data } = await api.post('/backend/auth.php', formData);

      if (data.success) {
        const userData: User = {
          id: data.user_id,
          username: data.username,
          email: email,
          isOnline: true,
          lastSeen: new Date()
        };
        
        localStorage.setItem('authToken', data.token);
        localStorage.setItem('user', JSON.stringify(userData));
        setUser(userData);
      } else {
        throw new Error(data.message || 'Login failed');
      }
    } catch (error) {
      throw error;
    }
  };

  const signup = async (username: string, email: string, password: string, profilePicture?: File) => {
    try {
      const formData = new FormData();
      formData.append('username', username);
      formData.append('email', email);
      formData.append('password', password);
      if (profilePicture) {
        formData.append('profile_picture', profilePicture);
      }

      const { data } = await api.post('/backend/createUser.php', formData);

      if (data.success) {
        await login(email, password);
      } else {
        throw new Error(data.message || 'Signup failed');
      }
    } catch (error) {
      throw error;
    }
  };

  const logout = () => {
    localStorage.removeItem('authToken');
    localStorage.removeItem('user');
    setUser(null);
  };

  return (
    <AuthContext.Provider value={{ user, login, signup, logout, isLoading }}>
      {children}
    </AuthContext.Provider>
  );
};

export const useAuth = () => {
  const context = useContext(AuthContext);
  if (context === undefined) {
    throw new Error('useAuth must be used within an AuthProvider');
  }
  return context;
};

================================================
File: frontend/src/contexts/CallContext.tsx
================================================
import React, { createContext, useContext, useEffect, useState, useRef } from 'react';
import Peer, { MediaConnection } from 'peerjs';
import { User } from '../types';
import { socket, registerUser, initiateCall, acceptCall, rejectCall, endCall as endCallSocket, onIncomingCall, onCallAccepted, onCallRejected, onCallEnded } from '../lib/socket';

interface CallContextType {
  makeCall: (user: User, isVideo: boolean) => void;
  answerCall: (call: MediaConnection) => void;
  endCall: () => void;
  toggleVideo: () => void;
  toggleAudio: () => void;
  incomingCall: MediaConnection | null;
  isInCall: boolean;
  localStream: MediaStream | null;
  remoteStream: MediaStream | null;
  isVideo: boolean;
  isMuted: boolean;
  caller: User | null;
}

const CallContext = createContext<CallContextType | undefined>(undefined);

export const CallProvider: React.FC<{ children: React.ReactNode; currentUser: User | null }> = ({
  children,
  currentUser
}) => {
  const [peer, setPeer] = useState<Peer | null>(null);
  const [incomingCall, setIncomingCall] = useState<MediaConnection | null>(null);
  const [isInCall, setIsInCall] = useState(false);
  const [localStream, setLocalStream] = useState<MediaStream | null>(null);
  const [remoteStream, setRemoteStream] = useState<MediaStream | null>(null);
  const [isVideo, setIsVideo] = useState(true);
  const [isMuted, setIsMuted] = useState(false);
  const [caller, setCaller] = useState<User | null>(null);
  
  const currentCallRef = useRef<MediaConnection | null>(null);
  const peerRef = useRef<Peer | null>(null);

  useEffect(() => {
    if (!currentUser) return;

    // Initialize PeerJS
    const newPeer = new Peer(currentUser.id, {
      host: 'localhost',
      port: 9000,
      path: '/',
      debug: 3
    });

    newPeer.on('open', (id) => {
      console.log('PeerJS connection established with ID:', id);
      setPeer(newPeer);
      // Register user with Socket.IO
      registerUser({
        id: currentUser.id,
        username: currentUser.username
      });
    });

    newPeer.on('call', (call) => {
      console.log('Incoming call from:', call.metadata);
      setIncomingCall(call);
    });

    peerRef.current = newPeer;

    // Socket.IO event listeners
    onIncomingCall(({ callerId, callerName, isVideo }) => {
      console.log('Incoming call notification:', { callerId, callerName, isVideo });
      setCaller({
        id: callerId,
        username: callerName,
        email: '',
        isOnline: true
      });
    });

    onCallAccepted(({ accepterId }) => {
      console.log('Call accepted by:', accepterId);
    });

    onCallRejected(({ rejecterId }) => {
      console.log('Call rejected by:', rejecterId);
      endCall();
    });

    onCallEnded(({ enderId }) => {
      console.log('Call ended by:', enderId);
      endCall();
    });

    return () => {
      if (peerRef.current) {
        peerRef.current.destroy();
      }
      if (localStream) {
        localStream.getTracks().forEach(track => track.stop());
      }
    };
  }, [currentUser]);

  const getMediaStream = async (video: boolean) => {
    try {
      const stream = await navigator.mediaDevices.getUserMedia({
        video: video ? {
          width: { ideal: 1280 },
          height: { ideal: 720 }
        } : false,
        audio: true
      });
      return stream;
    } catch (err) {
      console.error('Failed to get media stream:', err);
      return null;
    }
  };

  const makeCall = async (user: User, withVideo: boolean) => {
    if (!peerRef.current || !currentUser) return;

    try {
      const stream = await getMediaStream(withVideo);
      if (!stream) return;

      setLocalStream(stream);
      setIsVideo(withVideo);
      setIsInCall(true);

      // Notify through Socket.IO
      initiateCall(user.id, currentUser.id, currentUser.username, withVideo);

      const call = peerRef.current.call(user.id, stream, {
        metadata: { 
          callerId: currentUser.id,
          callerName: currentUser.username,
          isVideo: withVideo
        }
      });

      currentCallRef.current = call;
      setupCallEventHandlers(call);
      setCaller(currentUser);
    } catch (err) {
      console.error('Error making call:', err);
      endCall();
    }
  };

  const answerCall = async (call: MediaConnection) => {
    if (!currentUser) return;

    try {
      const isVideoCall = call.metadata?.isVideo;
      const stream = await getMediaStream(isVideoCall);
      if (!stream) return;

      setLocalStream(stream);
      setIsVideo(isVideoCall);
      setIsInCall(true);
      
      call.answer(stream);
      currentCallRef.current = call;
      setupCallEventHandlers(call);
      setIncomingCall(null);

      // Notify through Socket.IO
      acceptCall(call.metadata.callerId, currentUser.id);
      
      if (call.metadata?.callerId && call.metadata?.callerName) {
        setCaller({
          id: call.metadata.callerId,
          username: call.metadata.callerName,
          email: '',
          isOnline: true
        });
      }
    } catch (err) {
      console.error('Error answering call:', err);
      endCall();
    }
  };

  const setupCallEventHandlers = (call: MediaConnection) => {
    call.on('stream', (remoteMediaStream) => {
      setRemoteStream(remoteMediaStream);
    });

    call.on('close', () => {
      endCall();
    });

    call.on('error', (err) => {
      console.error('Call error:', err);
      endCall();
    });
  };

  const endCall = () => {
    if (currentCallRef.current && caller) {
      currentCallRef.current.close();
      // Notify through Socket.IO
      endCallSocket(caller.id, currentUser?.id || '');
    }
    
    if (localStream) {
      localStream.getTracks().forEach(track => track.stop());
    }
    
    setLocalStream(null);
    setRemoteStream(null);
    setIsInCall(false);
    setIncomingCall(null);
    setCaller(null);
    currentCallRef.current = null;
  };

  const toggleVideo = async () => {
    if (!localStream) return;

    if (isVideo) {
      localStream.getVideoTracks().forEach(track => {
        track.stop();
      });
      setIsVideo(false);
    } else {
      try {
        const newStream = await getMediaStream(true);
        if (newStream && currentCallRef.current) {
          currentCallRef.current.peerConnection?.getSenders().forEach(sender => {
            if (sender.track?.kind === 'video') {
              const videoTrack = newStream.getVideoTracks()[0];
              sender.replaceTrack(videoTrack);
            }
          });
          setLocalStream(newStream);
          setIsVideo(true);
        }
      } catch (err) {
        console.error('Error toggling video:', err);
      }
    }
  };

  const toggleAudio = () => {
    if (!localStream) return;
    
    const audioTrack = localStream.getAudioTracks()[0];
    if (audioTrack) {
      audioTrack.enabled = !audioTrack.enabled;
      setIsMuted(!audioTrack.enabled);
    }
  };

  return (
    <CallContext.Provider
      value={{
        makeCall,
        answerCall,
        endCall,
        toggleVideo,
        toggleAudio,
        incomingCall,
        isInCall,
        localStream,
        remoteStream,
        isVideo,
        isMuted,
        caller
      }}
    >
      {children}
    </CallContext.Provider>
  );
};

export const useCall = () => {
  const context = useContext(CallContext);
  if (context === undefined) {
    throw new Error('useCall must be used within a CallProvider');
  }
  return context;
};

================================================
File: frontend/src/contexts/ThemeContext.tsx
================================================
import React, { createContext, useContext, useState, useEffect } from 'react';

type Theme = 'light' | 'dark';

interface ThemeContextType {
  theme: Theme;
  toggleTheme: () => void;
}

const ThemeContext = createContext<ThemeContextType | undefined>(undefined);

export const ThemeProvider: React.FC<{ children: React.ReactNode }> = ({ children }) => {
  const [theme, setTheme] = useState<Theme>(() => {
    const saved = localStorage.getItem('theme');
    return (saved as Theme) || 'light';
  });

  useEffect(() => {
    localStorage.setItem('theme', theme);
    document.documentElement.classList.toggle('dark', theme === 'dark');
  }, [theme]);

  const toggleTheme = () => {
    setTheme(prev => prev === 'light' ? 'dark' : 'light');
  };

  return (
    <ThemeContext.Provider value={{ theme, toggleTheme }}>
      {children}
    </ThemeContext.Provider>
  );
};

export const useTheme = () => {
  const context = useContext(ThemeContext);
  if (context === undefined) {
    throw new Error('useTheme must be used within a ThemeProvider');
  }
  return context;
};

================================================
File: frontend/src/lib/axios.ts
================================================
import axios from 'axios';

const api = axios.create({
  baseURL: 'http://localhost:5000/',
  headers: {
    'Content-Type': 'multipart/form-data',
  },
});

// Add auth token to requests if it exists
api.interceptors.request.use((config) => {
  const token = localStorage.getItem('authToken');
  if (token) {
    config.headers.Authorization = `Bearer ${token}`;
  }
  return config;
});

export default api;


================================================
File: frontend/src/lib/socket.ts
================================================
import { io } from 'socket.io-client';

const SOCKET_URL = 'http://localhost:3001';

export const socket = io(SOCKET_URL, {
  autoConnect: true,
  reconnection: true,
  reconnectionAttempts: 5,
  reconnectionDelay: 1000
});

export const registerUser = (userData: { id: string; username: string }) => {
  socket.emit('register-user', userData);
};

export const initiateCall = (targetUserId: string, callerId: string, callerName: string, isVideo: boolean) => {
  socket.emit('call-user', { targetUserId, callerId, callerName, isVideo });
};

export const acceptCall = (targetUserId: string, accepterId: string) => {
  socket.emit('call-accepted', { targetUserId, accepterId });
};

export const rejectCall = (targetUserId: string, rejecterId: string) => {
  socket.emit('call-rejected', { targetUserId, rejecterId });
};

export const endCall = (targetUserId: string, enderId: string) => {
  socket.emit('call-ended', { targetUserId, enderId });
};

// Event listeners
export const onIncomingCall = (callback: (data: { callerId: string; callerName: string; isVideo: boolean }) => void) => {
  socket.on('incoming-call', callback);
};

export const onCallAccepted = (callback: (data: { accepterId: string }) => void) => {
  socket.on('call-accepted', callback);
};

export const onCallRejected = (callback: (data: { rejecterId: string }) => void) => {
  socket.on('call-rejected', callback);
};

export const onCallEnded = (callback: (data: { enderId: string }) => void) => {
  socket.on('call-ended', callback);
};

export const onUsersUpdated = (callback: (users: Array<{ id: string; username: string; isOnline: boolean }>) => void) => {
  socket.on('users-updated', callback);
};

================================================
File: frontend/src/pages/Chat.tsx
================================================
import React, { useState, useEffect, useCallback } from 'react';
import { User, Message } from '../types';
import { ChatWindow } from '../components/ChatWindow';
import { UserList } from '../components/UserList';
import { Header } from '../components/Header';
import { useAuth } from '../contexts/AuthContext';
import api from '../lib/axios';
import { motion, AnimatePresence } from 'framer-motion';

export const Chat: React.FC = () => {
  const { user } = useAuth();
  const [selectedUser, setSelectedUser] = useState<User | null>(null);
  const [messages, setMessages] = useState<Message[]>([]);
  const [loading, setLoading] = useState(false);

  // Load messages
  const loadMessages = useCallback(async () => {
    if (!user || !selectedUser) return;

    try {
      const formData = new FormData();
      formData.append('user_id', user.id);
      formData.append('other_user_id', selectedUser.id);

      const response = await api.post('/backend/loadChat.php', formData);
      console.log('Load messages response:', response.data); // Debug log

      // Check if response.data is a string (error message)
      if (typeof response.data === 'string') {
        if (response.data !== 'No messages found.') {
          console.error('Server error:', response.data);
        }
        return;
      }
      
      // Ensure we have an array of messages
      const messageData = Array.isArray(response.data) ? response.data : [];
      
      const formattedMessages = messageData.map((msg: any) => ({
        id: msg.id.toString(),
        senderId: msg.sender_id,
        receiverId: msg.receiver_id,
        content: msg.message,
        timestamp: new Date(msg.timestamp),
        type: msg.type || 'text',
        fileUrl: msg.file_path
      }));

      setMessages(formattedMessages);
    } catch (error) {
      console.error('Failed to load messages:', error);
    }
  }, [user, selectedUser]);

  // Initial load and interval setup
  useEffect(() => {
    if (!selectedUser) return;

    setLoading(true);
    loadMessages().finally(() => setLoading(false));

    // Set up interval to load messages every second
    const interval = setInterval(loadMessages, 1000);

    return () => {
      clearInterval(interval);
      setMessages([]);
    };
  }, [selectedUser, loadMessages]);

  const handleSendMessage = async (content: string, type: 'text' | 'image' | 'file', file?: File) => {
    if (!user || !selectedUser) return;

    try {
      const formData = new FormData();
      formData.append('sender_id', user.id);
      formData.append('receiver_id', selectedUser.id);
      formData.append('message', content);
      formData.append('type', type);
      
      if (file) {
        formData.append('file', file);
      }

      // Add optimistic update
      const optimisticMessage: Message = {
        id: `temp-${Date.now()}`,
        senderId: user.id,
        receiverId: selectedUser.id,
        content,
        timestamp: new Date(),
        type,
        fileUrl: file ? URL.createObjectURL(file) : undefined
      };

      setMessages(prev => [...prev, optimisticMessage]);

      // Send the message
      const response = await api.post('/backend/sendMessage.php', formData);
      console.log('Send message response:', response.data); // Debug log

      if (response.data.error || (typeof response.data.message === 'string' && response.data.message.includes('Error'))) {
        // Remove optimistic message if there was an error
        setMessages(prev => prev.filter(msg => msg.id !== optimisticMessage.id));
        console.error('Failed to send message:', response.data.message || response.data.error);
        return;
      }

      // Force reload messages to get the real message with server ID
      await loadMessages();
    } catch (error) {
      console.error('Failed to send message:', error);
      // Remove the optimistic message if there was an error
      setMessages(prev => prev.filter(msg => !msg.id.startsWith('temp-')));
    }
  };

  return (
    <motion.div 
      initial={{ opacity: 0 }}
      animate={{ opacity: 1 }}
      className="h-screen flex flex-col bg-gray-50 dark:bg-discord-dark-900"
    >
      <Header />
      <div className="flex flex-1 overflow-hidden">
        <motion.div 
          initial={{ x: -50, opacity: 0 }}
          animate={{ x: 0, opacity: 1 }}
          transition={{ type: "spring", stiffness: 300, damping: 30 }}
          className="w-[400px] flex flex-col bg-white dark:bg-discord-dark-800 border-r border-gray-200 dark:border-discord-dark-900"
        >
          <UserList
            selectedUser={selectedUser}
            onSelectUser={setSelectedUser}
          />
        </motion.div>
        <AnimatePresence mode="wait">
          <motion.div 
            key={selectedUser?.id || 'empty'}
            initial={{ opacity: 0, x: 50 }}
            animate={{ opacity: 1, x: 0 }}
            exit={{ opacity: 0, x: 50 }}
            transition={{ type: "spring", stiffness: 300, damping: 30 }}
            className="flex-1"
          >
            <ChatWindow
              currentUser={user!}
              selectedUser={selectedUser}
              messages={messages}
              onSendMessage={handleSendMessage}
              loading={loading}
            />
          </motion.div>
        </AnimatePresence>
      </div>
    </motion.div>
  );
};

================================================
File: frontend/src/pages/Login.tsx
================================================
import React, { useState } from 'react';
import { Link, useNavigate } from 'react-router-dom';
import { useAuth } from '../contexts/AuthContext';
import { MessageCircle } from 'lucide-react';

export const Login: React.FC = () => {
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const [error, setError] = useState('');
  const [isLoading, setIsLoading] = useState(false);
  const { login } = useAuth();
  const navigate = useNavigate();

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    setError('');
    setIsLoading(true);

    try {
      await login(email, password);
      navigate('/');
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Failed to login');
    } finally {
      setIsLoading(false);
    }
  };

  return (
    <div className="min-h-screen flex items-center justify-center bg-gray-50 dark:bg-discord-dark-900 px-4">
      <div className="max-w-md w-full space-y-8 bg-white dark:bg-discord-dark-800 p-8 rounded-lg shadow-md">
        <div className="text-center">
          <MessageCircle className="mx-auto h-12 w-12 text-discord-primary" />
          <h2 className="mt-6 text-3xl font-bold text-gray-900 dark:text-white">Welcome back!</h2>
          <p className="mt-2 text-sm text-gray-600 dark:text-gray-400">
            Please sign in to your account
          </p>
        </div>

        {error && (
          <div className="bg-red-100 dark:bg-red-900/30 border border-red-400 text-red-700 dark:text-red-400 px-4 py-3 rounded relative">
            {error}
          </div>
        )}

        <form className="mt-8 space-y-6" onSubmit={handleSubmit}>
          <div className="space-y-4">
            <div>
              <label htmlFor="email" className="block text-sm font-medium text-gray-700 dark:text-gray-300">
                Email address
              </label>
              <input
                id="email"
                type="email"
                required
                value={email}
                onChange={(e) => setEmail(e.target.value)}
                className="mt-1 block w-full px-3 py-2 bg-white dark:bg-discord-dark-600 border border-gray-300 dark:border-discord-dark-900 rounded-md shadow-sm text-gray-900 dark:text-white focus:outline-none focus:ring-discord-primary focus:border-discord-primary"
              />
            </div>
            <div>
              <label htmlFor="password" className="block text-sm font-medium text-gray-700 dark:text-gray-300">
                Password
              </label>
              <input
                id="password"
                type="password"
                required
                value={password}
                onChange={(e) => setPassword(e.target.value)}
                className="mt-1 block w-full px-3 py-2 bg-white dark:bg-discord-dark-600 border border-gray-300 dark:border-discord-dark-900 rounded-md shadow-sm text-gray-900 dark:text-white focus:outline-none focus:ring-discord-primary focus:border-discord-primary"
              />
            </div>
          </div>

          <button
            type="submit"
            disabled={isLoading}
            className="w-full flex justify-center py-2 px-4 border border-transparent rounded-md shadow-sm text-sm font-medium text-white bg-discord-primary hover:bg-discord-primary/90 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-discord-primary disabled:opacity-50"
          >
            {isLoading ? 'Signing in...' : 'Sign in'}
          </button>

          <div className="text-center text-sm">
            <span className="text-gray-600 dark:text-gray-400">Don't have an account? </span>
            <Link to="/signup" className="font-medium text-discord-primary hover:text-discord-primary/90">
              Sign up
            </Link>
          </div>
        </form>
      </div>
    </div>
  );
};

================================================
File: frontend/src/pages/Signup.tsx
================================================
import React, { useState } from 'react';
import { Link, useNavigate } from 'react-router-dom';
import { useAuth } from '../contexts/AuthContext';
import { MessageCircle, Upload } from 'lucide-react';

export const Signup: React.FC = () => {
  const [username, setUsername] = useState('');
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const [profilePicture, setProfilePicture] = useState<File | null>(null);
  const [previewUrl, setPreviewUrl] = useState<string | null>(null);
  const [error, setError] = useState('');
  const [isLoading, setIsLoading] = useState(false);
  const { signup } = useAuth();
  const navigate = useNavigate();

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    setError('');
    setIsLoading(true);

    try {
      await signup(username, email, password, profilePicture || undefined);
      navigate('/');
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Failed to create account');
    } finally {
      setIsLoading(false);
    }
  };

  const handleFileChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const file = e.target.files?.[0];
    if (file) {
      setProfilePicture(file);
      // Create preview URL
      const url = URL.createObjectURL(file);
      setPreviewUrl(url);
    }
  };

  return (
    <div className="min-h-screen flex items-center justify-center bg-gray-50 dark:bg-discord-dark-900 px-4">
      <div className="max-w-md w-full space-y-8 bg-white dark:bg-discord-dark-800 p-8 rounded-lg shadow-md">
        <div className="text-center">
          <MessageCircle className="mx-auto h-12 w-12 text-discord-primary" />
          <h2 className="mt-6 text-3xl font-bold text-gray-900 dark:text-white">Create an account</h2>
          <p className="mt-2 text-sm text-gray-600 dark:text-gray-400">
            Join our chat community
          </p>
        </div>

        {error && (
          <div className="bg-red-100 dark:bg-red-900/30 border border-red-400 text-red-700 dark:text-red-400 px-4 py-3 rounded relative">
            {error}
          </div>
        )}

        <form className="mt-8 space-y-6" onSubmit={handleSubmit}>
          <div className="space-y-4">
            <div>
              <label htmlFor="username" className="block text-sm font-medium text-gray-700 dark:text-gray-300">
                Username
              </label>
              <input
                id="username"
                type="text"
                required
                value={username}
                onChange={(e) => setUsername(e.target.value)}
                className="mt-1 block w-full px-3 py-2 bg-white dark:bg-discord-dark-600 border border-gray-300 dark:border-discord-dark-900 rounded-md shadow-sm text-gray-900 dark:text-white focus:outline-none focus:ring-discord-primary focus:border-discord-primary"
              />
            </div>
            <div>
              <label htmlFor="email" className="block text-sm font-medium text-gray-700 dark:text-gray-300">
                Email address
              </label>
              <input
                id="email"
                type="email"
                required
                value={email}
                onChange={(e) => setEmail(e.target.value)}
                className="mt-1 block w-full px-3 py-2 bg-white dark:bg-discord-dark-600 border border-gray-300 dark:border-discord-dark-900 rounded-md shadow-sm text-gray-900 dark:text-white focus:outline-none focus:ring-discord-primary focus:border-discord-primary"
              />
            </div>
            <div>
              <label htmlFor="password" className="block text-sm font-medium text-gray-700 dark:text-gray-300">
                Password
              </label>
              <input
                id="password"
                type="password"
                required
                value={password}
                onChange={(e) => setPassword(e.target.value)}
                className="mt-1 block w-full px-3 py-2 bg-white dark:bg-discord-dark-600 border border-gray-300 dark:border-discord-dark-900 rounded-md shadow-sm text-gray-900 dark:text-white focus:outline-none focus:ring-discord-primary focus:border-discord-primary"
              />
            </div>
            <div>
              <label className="block text-sm font-medium text-gray-700 dark:text-gray-300">
                Profile Picture
              </label>
              <div className="mt-1 flex flex-col items-center space-y-4">
                {previewUrl ? (
                  <div className="relative group">
                    <img
                      src={previewUrl}
                      alt="Profile preview"
                      className="w-32 h-32 rounded-full object-cover"
                    />
                    <div 
                      className="absolute inset-0 flex items-center justify-center bg-black bg-opacity-50 rounded-full opacity-0 group-hover:opacity-100 transition-opacity cursor-pointer"
                      onClick={() => {
                        setPreviewUrl(null);
                        setProfilePicture(null);
                      }}
                    >
                      <span className="text-white text-sm">Remove</span>
                    </div>
                  </div>
                ) : (
                  <div className="flex flex-col items-center">
                    <label className="w-32 h-32 flex flex-col items-center justify-center border-2 border-gray-300 dark:border-discord-dark-900 border-dashed rounded-full cursor-pointer hover:border-discord-primary dark:hover:border-discord-primary">
                      <Upload className="w-8 h-8 text-gray-400" />
                      <input
                        type="file"
                        className="hidden"
                        onChange={handleFileChange}
                        accept="image/*"
                      />
                      <span className="mt-2 text-sm text-gray-500 dark:text-gray-400">Upload</span>
                    </label>
                  </div>
                )}
              </div>
            </div>
          </div>

          <button
            type="submit"
            disabled={isLoading}
            className="w-full flex justify-center py-2 px-4 border border-transparent rounded-md shadow-sm text-sm font-medium text-white bg-discord-primary hover:bg-discord-primary/90 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-discord-primary disabled:opacity-50"
          >
            {isLoading ? 'Creating account...' : 'Sign up'}
          </button>

          <div className="text-center text-sm">
            <span className="text-gray-600 dark:text-gray-400">Already have an account? </span>
            <Link to="/login" className="font-medium text-discord-primary hover:text-discord-primary/90">
              Sign in
            </Link>
          </div>
        </form>
      </div>
    </div>
  );
};


================================================
File: frontend/src/types/index.ts
================================================
export interface User {
  id: string;
  username: string;
  email: string;
  avatar?: string;
  isOnline: boolean;
}

export interface Message {
  id: string;
  senderId: string;
  receiverId: string;
  content: string;
  timestamp: Date;
  type: 'text' | 'image' | 'file';
  fileUrl?: string;
}

export interface Conversation {
  id: string;
  participants: User[];
  lastMessage?: Message;
}

================================================
File: frontend/src/utils/dateUtils.ts
================================================
export const formatMessageTime = (date: Date): string => {
  return new Date(date).toLocaleTimeString('en-US', {
    hour: 'numeric',
    minute: '2-digit',
    hour12: true
  });
};

export const formatLastSeen = (date: Date | undefined): string => {
  if (!date) return '';
  
  const now = new Date();
  const messageDate = new Date(date);
  const diffInHours = (now.getTime() - messageDate.getTime()) / (1000 * 60 * 60);
  
  if (diffInHours < 24) {
    return formatMessageTime(messageDate);
  } else if (diffInHours < 48) {
    return 'Yesterday';
  } else {
    return messageDate.toLocaleDateString('en-US', {
      month: 'short',
      day: 'numeric'
    });
  }
};

================================================
File: frontend/.vite/deps/_metadata.json
================================================
{
  "hash": "f5d30a97",
  "configHash": "affadd16",
  "lockfileHash": "e3b0c442",
  "browserHash": "ac255ae3",
  "optimized": {},
  "chunks": {}
}

================================================
File: frontend/.vite/deps/package.json
================================================
{
  "type": "module"
}